//
// Generated file, do not edit! Created by nedtool 4.6 from nodes/messages/ARAmessages.msg.
//

#ifndef _ARAMESSAGES_M_H_
#define _ARAMESSAGES_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include "SimpleAddress.h"
// }}

/**
 * Class generated from <tt>nodes/messages/ARAmessages.msg:25</tt> by nedtool.
 * <pre>
 * packet RETRY
 * {
 *     bool flag;
 * }
 * 
 * //packet ROUTE_ERROR{
 * //    LAddress::L3Type my_addr;
 * //    LAddress::L3Type dest_addr;
 * //}
 * //
 * //packet FANT {
 * //    int id;
 * //    double pheromone_value;
 * //    double hops;
 * //    LAddress::L3Type dest_addr;
 * //    LAddress::L3Type previous_addr;
 * //    LAddress::L3Type source_addr;
 * //}
 * //
 * //packet BANT {
 * //    double pheromone_value;
 * //    double hops;
 * //    int id;
 * //    LAddress::L3Type dest_addr;
 * //    LAddress::L3Type next_addr;
 * //    LAddress::L3Type source_addr;
 * //    LAddress::L3Type previous_addr;
 * //}
 * //
 * //packet DATA {
 * //    int data;    
 * //    double pheromone_value;
 * //    double hops;
 * //    int id;
 * //    int TTL;
 * //    bool forward;
 * //    bool ERROR;    
 * //    LAddress::L3Type my_addr;
 * //    LAddress::L3Type dest_addr;
 * //    LAddress::L3Type next_addr;
 * //    LAddress::L3Type source_addr;
 * //
 * //}
 * </pre>
 */
class RETRY : public ::cPacket
{
  protected:
    bool flag_var;

  private:
    void copy(const RETRY& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RETRY&);

  public:
    RETRY(const char *name=NULL, int kind=0);
    RETRY(const RETRY& other);
    virtual ~RETRY();
    RETRY& operator=(const RETRY& other);
    virtual RETRY *dup() const {return new RETRY(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getFlag() const;
    virtual void setFlag(bool flag);
};

inline void doPacking(cCommBuffer *b, RETRY& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RETRY& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>nodes/messages/ARAmessages.msg:68</tt> by nedtool.
 * <pre>
 * packet ROUTE_ERROR
 * {
 *     int my_addr;
 *     int dest_addr;
 * }
 * </pre>
 */
class ROUTE_ERROR : public ::cPacket
{
  protected:
    int my_addr_var;
    int dest_addr_var;

  private:
    void copy(const ROUTE_ERROR& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ROUTE_ERROR&);

  public:
    ROUTE_ERROR(const char *name=NULL, int kind=0);
    ROUTE_ERROR(const ROUTE_ERROR& other);
    virtual ~ROUTE_ERROR();
    ROUTE_ERROR& operator=(const ROUTE_ERROR& other);
    virtual ROUTE_ERROR *dup() const {return new ROUTE_ERROR(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMy_addr() const;
    virtual void setMy_addr(int my_addr);
    virtual int getDest_addr() const;
    virtual void setDest_addr(int dest_addr);
};

inline void doPacking(cCommBuffer *b, ROUTE_ERROR& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ROUTE_ERROR& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>nodes/messages/ARAmessages.msg:73</tt> by nedtool.
 * <pre>
 * packet FANT
 * {
 *     int id;
 *     double pheromone_value;
 *     double hops;
 *     int dest_addr;
 *     int previous_addr;
 *     int source_addr;
 * }
 * </pre>
 */
class FANT : public ::cPacket
{
  protected:
    int id_var;
    double pheromone_value_var;
    double hops_var;
    int dest_addr_var;
    int previous_addr_var;
    int source_addr_var;

  private:
    void copy(const FANT& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FANT&);

  public:
    FANT(const char *name=NULL, int kind=0);
    FANT(const FANT& other);
    virtual ~FANT();
    FANT& operator=(const FANT& other);
    virtual FANT *dup() const {return new FANT(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getId() const;
    virtual void setId(int id);
    virtual double getPheromone_value() const;
    virtual void setPheromone_value(double pheromone_value);
    virtual double getHops() const;
    virtual void setHops(double hops);
    virtual int getDest_addr() const;
    virtual void setDest_addr(int dest_addr);
    virtual int getPrevious_addr() const;
    virtual void setPrevious_addr(int previous_addr);
    virtual int getSource_addr() const;
    virtual void setSource_addr(int source_addr);
};

inline void doPacking(cCommBuffer *b, FANT& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FANT& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>nodes/messages/ARAmessages.msg:82</tt> by nedtool.
 * <pre>
 * packet BANT
 * {
 *     double pheromone_value;
 *     double hops;
 *     int id;
 *     int dest_addr;
 *     int next_addr;
 *     int source_addr;
 *     int previous_addr;
 * }
 * </pre>
 */
class BANT : public ::cPacket
{
  protected:
    double pheromone_value_var;
    double hops_var;
    int id_var;
    int dest_addr_var;
    int next_addr_var;
    int source_addr_var;
    int previous_addr_var;

  private:
    void copy(const BANT& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BANT&);

  public:
    BANT(const char *name=NULL, int kind=0);
    BANT(const BANT& other);
    virtual ~BANT();
    BANT& operator=(const BANT& other);
    virtual BANT *dup() const {return new BANT(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getPheromone_value() const;
    virtual void setPheromone_value(double pheromone_value);
    virtual double getHops() const;
    virtual void setHops(double hops);
    virtual int getId() const;
    virtual void setId(int id);
    virtual int getDest_addr() const;
    virtual void setDest_addr(int dest_addr);
    virtual int getNext_addr() const;
    virtual void setNext_addr(int next_addr);
    virtual int getSource_addr() const;
    virtual void setSource_addr(int source_addr);
    virtual int getPrevious_addr() const;
    virtual void setPrevious_addr(int previous_addr);
};

inline void doPacking(cCommBuffer *b, BANT& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BANT& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>nodes/messages/ARAmessages.msg:92</tt> by nedtool.
 * <pre>
 * packet DATA
 * {
 *     int data;
 *     double pheromone_value;
 *     double hops;
 *     int id;
 *     int TTL;
 *     bool forward;
 *     bool ERROR;
 *     int my_addr;
 *     int dest_addr;
 *     int next_addr;
 *     int source_addr;
 * 
 * }
 * </pre>
 */
class DATA : public ::cPacket
{
  protected:
    int data_var;
    double pheromone_value_var;
    double hops_var;
    int id_var;
    int TTL_var;
    bool forward_var;
    bool ERROR_var;
    int my_addr_var;
    int dest_addr_var;
    int next_addr_var;
    int source_addr_var;

  private:
    void copy(const DATA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DATA&);

  public:
    DATA(const char *name=NULL, int kind=0);
    DATA(const DATA& other);
    virtual ~DATA();
    DATA& operator=(const DATA& other);
    virtual DATA *dup() const {return new DATA(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getData() const;
    virtual void setData(int data);
    virtual double getPheromone_value() const;
    virtual void setPheromone_value(double pheromone_value);
    virtual double getHops() const;
    virtual void setHops(double hops);
    virtual int getId() const;
    virtual void setId(int id);
    virtual int getTTL() const;
    virtual void setTTL(int TTL);
    virtual bool getForward() const;
    virtual void setForward(bool forward);
    virtual bool getERROR() const;
    virtual void setERROR(bool ERROR);
    virtual int getMy_addr() const;
    virtual void setMy_addr(int my_addr);
    virtual int getDest_addr() const;
    virtual void setDest_addr(int dest_addr);
    virtual int getNext_addr() const;
    virtual void setNext_addr(int next_addr);
    virtual int getSource_addr() const;
    virtual void setSource_addr(int source_addr);
};

inline void doPacking(cCommBuffer *b, DATA& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DATA& obj) {obj.parsimUnpack(b);}


#endif // ifndef _ARAMESSAGES_M_H_

